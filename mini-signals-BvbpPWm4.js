class t{constructor(t,n=!1,i){this._fn=t,this._once=n,this._thisArg=i,this._next=this._prev=this._owner=null}detach(){return null!==this._owner&&(this._owner.detach(this),!0)}}function n(t,n){return t._head?(t._tail._next=n,n._prev=t._tail,t._tail=n):(t._head=n,t._tail=n),n._owner=t,n}class i{constructor(){this._head=this._tail=void 0}handlers(t=!1){let n=this._head;if(t)return!!n;const i=[];for(;n;)i.push(n),n=n._next;return i}has(n){if(!(n instanceof t))throw new Error("MiniSignal#has(): First arg must be a MiniSignalBinding object.");return n._owner===this}dispatch(){let t=this._head;if(!t)return!1;for(;t;)t._once&&this.detach(t),t._fn.apply(t._thisArg,arguments),t=t._next;return!0}add(i,e=null){if("function"!=typeof i)throw new Error("MiniSignal#add(): First arg must be a Function.");return n(this,new t(i,!1,e))}once(i,e=null){if("function"!=typeof i)throw new Error("MiniSignal#once(): First arg must be a Function.");return n(this,new t(i,!0,e))}detach(n){if(!(n instanceof t))throw new Error("MiniSignal#detach(): First arg must be a MiniSignalBinding object.");return n._owner!==this||(n._prev&&(n._prev._next=n._next),n._next&&(n._next._prev=n._prev),n===this._head?(this._head=n._next,null===n._next&&(this._tail=null)):n===this._tail&&(this._tail=n._prev,this._tail._next=null),n._owner=null),this}detachAll(){let t=this._head;if(!t)return this;for(this._head=this._tail=null;t;)t._owner=null,t=t._next;return this}}export{i as M};
